***********************************************************************************************************************
										Памятка разработчику в проекте MyDB.
***********************************************************************************************************************

I. Переменные, аргументы функций и члены классов

  * Объявляйте переменные непосредственно перед их использованием в коде.

  * Переменные, которые не модифицируются после инициализации, должны быть объявлены как const.
	Это же относится и к членам классов: если член не модифицируется после создания объекта,
	его необходимо объявить константным.

  * Имена переменных ВСЕГДА пишутся с маленькой буквы, пример: std::int32_t objectsCount;

  * Аргументы функций (методов) именуются так же, как и обычные переменные.

  * Члены классов и структур начинаются с префикса m_, статические члены - с префикса sm_.
	Глобальные переменные начинаются с префикса g_, но их использования следует избегать.

  * За исключением предыдущего случая переменные не должны иметь никаких префиксов
	и подчерков в своем названии.

  * Если в типе переменной встречается слово const, оно пишется справа от типа, к которому
	относится. Примеры:
	const std::int32_t a = 10; // неправильно
	std::int32_t const a = 10; // правильно
	void UseIndex(const int const * & index); // неправильно
	void UseIndex(int const * const & index); // правильно

  * Статические константы именуются заглавными буквами и с подчерками для разделения слов.
	Обыкновенные константы, инициализируемые во время выполнения кода, именуются так же, как
	и переменные.
	Пример:
	static std::int64_t const SMINUTE = 60; // правильно
	static std::int64_t const MAX_BUFFER_TIME_INTERVAL = 5 * SMINUTE; // правильно
	std::uint64_t const fileSize = file->getSize(); // правильно, константа не статическая
	std::uint32_t const FILE_SIZE = file->getSize(); // неправильно

II. Методы и функции, их реализация

  * Все функции пишутся с большой буквы: std::int32_t CreateObject();

  * Имена методов и функций начинаются с глаголов, например:
	std::size_t Size();    // неправильно;
	std::size_t GetSize(); // правильно.

  * Все методы, которые по логике не изменяют состояние объекта, обязательно должны быть
	объявлены константными.

  * Пробелами отделяются все операторы, символы указателей, ссылок и т.п.
	T *var1=var2*( var3+3 );                  // неправильно
	T * var1 = var2 * (var3 + 3);             // правильно
	std::uint8_t array[3] = {1, 2, 3};        // правильно
	void Do(A const &value,B &result);        // неправильно
	void Do(A const & value, B & result);     // правильно
	bool operator!=(A const & other) const;   // неправильно
	bool operator != (A const & other) const; // правильно

	Исключениями являются пробелы внутри скобках (условия, вызовы функций, обращения по индексу и т.п.).

  * В случае if, catch, while, for и других ключевых слов, пробел после них ставится:
	for(std::uint8_t i = 0; i < 16; ++i)  // неправильно
	for (std::uint8_t i = 0; i < 16; ++i) // правильно

	При объявлении, определении и вызове функции пробел НЕ ставится. Примеры:
	void Do (A & value); // неправильно
	void Do(A & value);  // правильно
	Do (value);          // неправильно
	Do(value);           // правильно

  * Для организации отступа в начале строки используются только символы табуляции,
	для отступа внутри строки - только символы пробелов. 1 символ табуляции = 4 пробела.

  * Список инициализации в конструкторах рассматривается как составная конструкция и выглядит:
	SomeClass::SomeClass()
		: m_member1(value1) // всегда идёт со сдвигом в одину табуляцию
		, m_member2(value2)
	{
	}

  * В составных конструкциях однородные блоки сдвигаются на минимально необходимое одинаковое
	количество символов табуляции. Допускается дополнительная табуляция для визуального отделения
	разнородных блоков. Примеры:

	if (someLongVariable == someLongConstant ||
		anotherLongVariable == anotherLongConstant) 
	{
		performActionOne();
		performActionTwo();
	}

	MyFavoriteClass::MyFavoriteClass(MyFavoriteTypeOne const & argumentOne,
			MyFavoriteTypeTwo const & argumentTwo,
			MyFavoriteTypeThree & argumentThree,
			MyFavoriteTypeFour & argumentFour)
		: Named("Example")
		, m_member(
			new MyFavoriteServerFacade(argumentOne, argumentTwo, argumentThree),
			argumentFour
		) // скобка может быть перенесена для выразительности
	{}

  * Открывающая фигурная скобка всегда ставится на той же строке и предворяется пробелом.
    Исключения составляют случаи, когда предыдущая конструкция (условный оператор, список инициализации,
    вызов функции с большим количеством параметров и т.п.) занимают более 1 строки. В таких случаях
    фигурная скобка переносится. Примеры:

	if ( ... ) { ... }

	while (veryVeryLongConditionOne || 
		veryVeryLongConditionOne)
	{
		...
	}

  * Слово else пишется на новой строке, при том по возможности ставится на одну строку
	со следующим if. Пример:
	if ( ... ) {
	} else if ( ... )
		...

  * Разрешены однострочные методы, у которых тело располагается на той же строке, что и
	декларация. Однострочный метод должен являться геттером или сеттером, тело которого
	состоит из единственной операции (return либо присваивание соответственно). Примеры:
	size_t GetSize() const { return m_size; }
	void SetSize(std::size_t iSize) { m_size = iSize; }

  * Блоки try/catch, switch/case пишутся по тем же правилам, что и остальные составные
	конструкции. Пример использования switch/case:
	switch(variable) {
		case VALUE1: {
			SomeCall();
		}
		default:
			Error();
	}

  * Объявление шаблона всегда ставится на отдельной строке, предшествуя объявлению класса или
	функции. Пример:
	template<typename T>
	class SomeClass {
		template<class A, class B>
		void SomeMethod() {
		}
	};


III. Типы данных, классы, структуры

  * Для именования классов/структур/перечислений используется pascal case.

  * Описание класса начинается с его public раздела, затем идут protected и private
	разделы (порядок важен). Структура класса должна быть следующей
	class MyClass {
	public:
		// types

	public:
		// methods

	protected:
		// types

	protected:
		// methods

	protected:
		// variables		

	private:
		// same as protected
    };

  * Следует сортировать содержание класса по его значимости, частоте обращения.
	Наиболее часто используемые извне методы и типы должны находиться в начале,
	менее используемые методы, типы, а также переменные члены - в конце.

  * Перед началом каждого следующего раздела в классе оставляется пустая строка.


IV. Файловая структура

  * Все имена папок пишутся маленькими буквами. Все build targets пишутся маленькими буквами.

V. Правила оформления файлов с исходным кодом

  * Объявление класса находится в h-файле с тем же именем, что и имя класса.
	Например, описание класса List находится в файле List.h. Естественно, что несколько
	родственных и небольших классов разумнее и удобнее размещать в одном хедере.

  * Реализация всех методов класса находится в cpp-файле с тем же именем, что и имя класса.
	Исключения: шаблонные классы.

  * Шаблонные классы располагаются полностью в h-файлах, причем эти файлы должны иметь 
    расширение .hpp.

  * В заголовочных файлах должно быть минимальное количество директив #include. По возможности
	следует обходиться forward declaration вместо подключения соответствующих заголовков.


VI. Правила комментирования кода

  * Комментарии излагаются на понятном английском языке. При возникновении трудностей
	следует обращаться с вопросами к онлайн-переводчикам, затем - к коллегам.

  * Перед началом текста комментария идет пробел. Если комментарий представляет собой одно
	или несколько предложений, он обязан начинаться с заглавной буквы и заканчиваться точкой.
	Допускаются короткие комментарии, начинающиеся со строчной буквы, в этом случае точка на
	конце не ставится. Примеры:
	// This is a comment. It is rather long and needs point in the end. - верно
	// this is a short comment - также верно

  * Перед декларацией каждого класса идет комментарий, описывающий данный класс. Пример:
	/**
	 * @class McEndPointMessage
	 * The inter-process message to exchange data between EndPoints.
	 * @note AllData = Code (2 first bytes) + Content
	 */
	class McEndPointMessage

  * Перед декларацией каждого метода идет описывающий его комментарий. Пример:
	/**
	 * Sets all data from buffer.
	 * @param data - buffer where will copy from.
	 * @param size - size of the data buffer.
	 * @return true if successful, false otherwise.
	 * @note The iData buffer is not validated for correctness.
	 */
	bool SetAllDataFromBuffer(std::uint8_t const * data, std::size_t size);

  * Если комментарий к методу помещается на одной строчке, то скобки "/** */" можно заменить
	на "///". Данное правило не распространяется на комментарии к классам.

  * Внутри реализации методов можно использовать все виды комментариев. Скобочные
	(/* */, /** */) следует использовать только для многострочных комментариев.
	Doxygen-style комментарии позволяется использовать для подсветки более важных заметок.

  * Приветствуются слова TODO, FIXME, NOTE, WARNING (= что-то очень важное),
	за которыми обязательно должен следовать комментарий.


VII. Макросы

  * Случаи введения макросов считаются исключительными, но разрешены на страх и риск автора.
	Для каждого нововведенного макроса необходимо обосновывать причины его введения.
	Запрещается вводить макросы, которые могут повлечь очевидные сторонние эффекты:
	#define max(a, b) a>b?a:b // неправильно, max(++x, y) даст неожиданный результат

  * Макросы именуются так же, как и статические константы, за исключением
	"multi-include guard"-ов в хедерах:
	#ifndef MyPrettyHeader_h
	#define MyPrettyHeader_h
	...
	#endif // MyPrettyHeader_h


VIII. Советы на все случаи жизни

 0. По максимому старайтесь использовать идиому RAII и не писать в явном виде new и delete.
    Используйте умные указатели и контейнеры STL.

 1. Соблюдайте элементарные правила ООП! В частности, настоятельно рекомендуется
	инкапсулировать данные, скрывая переменные члены за методами классов.

 2. Не плодите сущности без надобности, но также избегайте смысловой перегрузки сущностей.
	Избегайте лишних связей, предпочитайте более слабые связи более сильным.

 4. Внимательно и творчески подходите к именованию сущностей. Имена переменных, функций,
	классов, подпроектов и т.п. должны чётко отражать главный концептуальный смысл
	обозначаемого, должны быть наглядны и легко читаемы.

 5. Не оптимизируйте, когда не следует. В проекте позволяется жертвовать незначительным
	приростом производительности ради ощутимого улучшения понятности и красоты кода.
	Кроме того, избегайте преждевременной оптимизации.

 6. Пишите и поддерживайте в актуальном состоянии тесты.

 7. Высказывайте любые конструктивные предложения по усовершенствованию проекта.
