### Описание структуры файла в котором хранится база данных
Реляционные базы данных не предполагают хранения всей информации в оперативной памяти, поэтому будет логично продумать
структуру файлов во внешней памяти, которые будут содержать информацию о базе данных, хранимых в ней таблицах, и 
содержимое страниц.

Существует несколько подходов для хранения таблиц во внешней памяти:
* Хранить файл с информацией о базе данных и какой-либо информацией позволяющей найти во внешней памяти данных из таблиц. 
(информация из таблиц в этом случае хранится в одном файле).
* Хранить один файл, который содержит в себе как служебную информацию о структуре и таблицах базы данных так и сами таблицы со
всей информацией.

Первый подход проще в реализации, но вызывает некоторые неудобства (какие?). Он применяется в некоторых встраиваемых БД,
пример - SQlite.

Второй подход требует продуманной структуры файла со всей базой (нужно включить заголовок, который должен содержать какую-то 
базовую информацию о имени базы данных, имеющихся таблицах с расположением каждой из них и места доступного для записи 
новой информации). Сейчас все наиболее серьезные базы данных (mssql, postgres etc) используют именно этот подход. Mydb не 
станет исключением.

#### О хранении информации внутри файла.
Как известно, данные хранятся ни где-нибудь, а на жестком диске, который иногда может вращаться. В связи с этим технология 
ограничивает минимальное количество информации, которое может быть считано за один запрос что-либо прочитать. (Т.е. когда 
мы просит у ФС прочитать 10 байт из внешней памяти, она только делает вид, что читает 10, на самом деле она прочитывает
значительно больше, а все что оказывается ненужным просто выбрасывает)

В связи с этим, может возникнуть желание, вместо того, чтобы читать информацию по слишком маленьким частям, читать немного
больше примерно за те же расходы на IO и работать с прочитанным куском памяти самостоятельно.

Теперь возникает задача выбора размера одного блока, который будет читаться из внешней памяти. Сейчас большиснтво жестких
дисков поддерживают следующую цифру - 4096 байт. Поэтому внутри нашей программы как единицу памяти разумно выбрать именно
эту величину, назвав её страницей. Адресацию страницы будет приводить в байтах, т.е. каждая страница содержит байты, 
которые задаются адресами 0,1,2,....,4095. Адресацию же страниц внутри файла будем делать аналогично: 0,1,2... То 
есть за каждой станицей можно закрепить постоянный уникальный идентификатор, по которому эту страницу можно будет найти 
памяти(вычислив отступ от начала файла). Будем считать, что для адресации страниц будет достаточно 4 байт (ими можно 
примерно 17 терабайт памяти)

В этом случае нужно как-то описать структуру каждой страницы, и возможно, разделить их на несколько типов по хранимой
на них информации.

Сразу можно придумать несколько типов информации которая будет храниться в памяти при выбранном методе хранения.
* Системная информация базы данных
* Страница описания таблицы
* Страница содержащая данные какой-либо **одной** таблицы

При этом какие-то данные для всех страниц могут быть одинаковыми, это следует учесть при отображении страницы в объекты,
~~если такое будет иметь место быть~~

Опишем возможную структуру каждого типа.
##### Общее для всех страниц. 
Необходимо опрределить поля для навигации по страницам. Страницы в памяти будет представлять как линейный двусвязный список,
каждое звено которого знает элемент, который ему предшествует, и который идет следующим на ним.
Будем хранить эту информацию в начале и конце каждой из сраниц.
* 0-31 Номер предыдущей страницы
* 32-4063 Содержимое страницы
* 4064-4095 Номер следующей страницы

##### Системная информация БД
Страница с системной информацией по всей БД - это **обязательно** первая страница в файле, которая соответсвует нашей
базе данных. Следовательно информация о предыдущей ненужна, вместо этого этот блок памяти можно использовать для 
установки признака того, что этот файл является файлов с базой данных, а не просто с какой-то произвольной информацией.

Определим несколько полей, которые будут описывать что за база данных хранится в этом файле.
32-95 Имя базы данных
96-99 Идентификатор первой чистой страницы в списке чистых страниц
100-4063 Информация о таблицах, которые есть в базе данных. Сразу же откажемся от хранения информации о структуре таблиц 
старнице с системой информацией, вместо этого перенесем эту ответственность на страницу с описанием таблицы. На этой странице
будем хранить только название и id страницы, где находится описатель таблицы.

Таким образом, ограничив длину на название таблиц 96 символами, получим следующие адреса для хранения информации о таблицах:

* 100-195. Название первой таблицы
* 196-199. Номер страницы с описанием для первой таблицы.
* 200-295. Название второй таблицы
* 296-299. Номер страницы с описанием второй таблицы
* Дальше, думаю понятно.

Если вдруг у нас появилось столько таблиц, что новые не вмещается на страницу, то нужно создать новую страницу, куда записывать
вновь появляющиеся таблицы.
##### Информация о таблице

Пока что непонятно что сюда включать. Нужно информацию о полях, из типах и размерах. Так же, в дальнейшем, нужно что-то
хранить и о индексах, которые есть на поля этой таблицы. Ещё нужно хранить указатель на страницу, с которой начианется 
информация в данной таблице

##### Таблица с данными

Вроде ничего не мешает хранить сырые данные, т.к. как их интерпретировать зависит от описания таблицы, к которой эти
относятся.

### О выделении новых страниц.

В какой-то момент выделенная память в одном файле может подойти к концу и потребуется выделить ещё. Тут может выделить 
две крайности:
* когда заканчивается память выделить ещё столько же сколько было до этого.
* выделить одну новую страницу.

В первом случае при большом размере файла с БД можем получить, что увеличение файла в 2 раза будет отжирать огромный объем
памяти.

Во втором при интенсивной записи в таблицу можем получим слиишком много операций IO, и будет работать долго, так же файл
с БД может получиться сильно фрагментированным, что ухудшит работу дискового кэша, и так же замедлит работу.

Поэтому, в случае когда заканчивается память, выберем нейтральную стратегию: будем выделять фиксированное количество новых 
страниц (100 или 1000, 400кб или 4 мб соответственно).

